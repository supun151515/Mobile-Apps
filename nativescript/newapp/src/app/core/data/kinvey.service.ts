// -------------------------------------------------------------------------
// <Auto-generated file - do not modify!>
//
// This code was generated automatically by Kinvey Studio.
//
// Changes to this file may cause undesired behavior and will be lost
// the next time the code regenerates.
//
// Find more information on https://devcenter.kinvey.com/guides/studio-extension-points.
// -------------------------------------------------------------------------
import { Injectable } from '@angular/core';
import { Observable, Subject, Subscription, combineLatest, from, of } from 'rxjs';
import { filter, flatMap, map } from 'rxjs/operators';

import { DataStoreService, FilesService, Query, Errors, AutoStore, Aggregation } from '@src/app/core/libs/kinvey-sdk';
import { DataServiceConfig } from '@src/app/core/data/interfaces/data-service-config.interface';
import { PagingDataResult } from '@src/app/core/data/interfaces/paging-data-result.interface';
import { NetworkMonitoringService } from '@src/app/core/services/network-monitoring.service';
import { CollectionState, AggregationState, GroupResult, GroupDescriptor, CompositeFilterDescriptor, isCompositeFilterDescriptor, FilterDescriptor, AggregationType } from '@src/app/core/data/data-state.service';

@Injectable()
export class KinveyService {
    protected dataReload: { [key: string]: Subject<any> } = {};
    protected syncCollection: { [key: string]: Subscription } = {};

    constructor(protected networkMonitoringService: NetworkMonitoringService,
        private dataStoreService: DataStoreService,
        private filesService: FilesService) {
    }

    public findById(config: DataServiceConfig, id: string): Observable<any> {
        // Kinvey Auto store does not use Rxjs. Returns promise instead of Observable
        return from(this.getDataStoreCollection(config).findById(id, config.requestOptions));
    }

    public find(config: DataServiceConfig, state: CollectionState): Observable<any[]> {
        const dataStoreCollection = this.getDataStoreCollection(config);
        const query = this.dataStateToKinveyQuery(state);

        // Kinvey Auto store does not use Rxjs. Returns promise instead of Observable
        return from(dataStoreCollection.find(query, config.requestOptions) as Promise<any[]>);
    }

    public findWithCount(config: DataServiceConfig, state: CollectionState): Observable<PagingDataResult<any>> {
        const dataStoreCollection = this.getDataStoreCollection(config);
        const query = this.dataStateToKinveyQuery(state);

        return combineLatest([
            dataStoreCollection.find(query, config.requestOptions) as Observable<[]>,
            dataStoreCollection.count(query, config.requestOptions) as Observable<number>
        ]).pipe(
            map(([data, total]) => ({ data, total }))
        );
    }

    public group(config: DataServiceConfig, state: AggregationState): Observable<GroupResult[]> {
        if (!state.group || state.group.length === 0) {
            return of([]);
        }

        const groupDesc: GroupDescriptor = state.group[0];

        if (!groupDesc.aggregates || groupDesc.aggregates.length === 0) {
            return of([]);
        }

        const aggregation = new Aggregation({
            key: {
                [groupDesc.field]: true
            },
            initial: this.buildGroupInitial(groupDesc),
            reduceFn: this.buildGroupReduce(groupDesc),
            query: state.filter ? new Query({ filter: this.buildCompositeFilter(state.filter) }) : undefined,
        });

        return from(this.getDataStoreCollection(config).group(aggregation))
            .pipe(map((response: any) => this.mapGroupResponse(groupDesc, response)));
    }

    public save(config: DataServiceConfig, item: any) {
        const plainItem = JSON.parse(JSON.stringify(item));
        if (!plainItem._id) {
            // if the id value is falsy treat it as a new item
            delete plainItem._id;
        }

        const savePromise = this.getDataStoreCollection(config)
            .save(plainItem, config.requestOptions);

        return this.networkMonitoringService.isOnline
            ? savePromise
            : new Promise(resolve => {
                setTimeout(() => resolve(plainItem), 200);
            });
    }

    public remove(config: DataServiceConfig, item) {
        return this.getDataStoreCollection(config)
            .removeById(item._id, config.requestOptions);
    }

    public filesUpload(requestOptions: any, file: {}, metadata?: any) {
        return this.filesService.upload(file, metadata, requestOptions);
    }

    public getDataReload(key: string) {
        this.dataReload[key] = this.dataReload[key] || new Subject<any>();
        return this.dataReload[key];
    }

    protected getDataStoreCollection(config: DataServiceConfig) {
        const dataStoreCollection = this.dataStoreService.collection(config.collection, config.dataStoreType);
        this.sync(config.collection, dataStoreCollection);
        return dataStoreCollection;
    }

    protected sync(collectionName: string, dataStoreCollection: AutoStore) {
        if (this.syncCollection[collectionName] || !dataStoreCollection.pendingSyncCount) {
            return;
        }

        this.syncCollection[collectionName] = this.networkMonitoringService.connectionObservable
            .pipe(
                filter(isOnline => isOnline),
                flatMap(() => from(dataStoreCollection.pendingSyncCount())),
                filter((count: any) => count > 0),
                flatMap(() => from(dataStoreCollection.sync()))
            )
            .subscribe(() => {
                const dr = this.getDataReload(collectionName);
                dr.next();
            });
    }

    protected dataStateToKinveyQuery(dataState: CollectionState): Query {
        const query = new Query();

        if (dataState.withinBox) {
            const { bottomLeftCoord, upperRightCoord } = dataState.withinBox;

            return (query.withinBox as any)('_geoloc', bottomLeftCoord, upperRightCoord);
        }

        if (typeof dataState.filter !== 'undefined') {
            query.filter = this.buildCompositeFilter(dataState.filter);
        }

        query.skip = dataState.skip || 0;
        query.limit = dataState.take || 20;

        if (typeof dataState.sort !== 'undefined') {
            const sortDef = {};

            dataState.sort.forEach(item => {
                if (item.dir && item.dir === 'desc') {
                    query.descending(item.field);
                } else {
                    query.ascending(item.field);
                }
            });
        }

        return query;
    }

    protected buildCompositeFilter(filterDesc: CompositeFilterDescriptor) {
        if (filterDesc.filters.length === 0) {
            return {};
        }

        return {
            ['$' + filterDesc.logic]: filterDesc.filters.map(item => {
                if (isCompositeFilterDescriptor(item)) {
                    return this.buildCompositeFilter(item as CompositeFilterDescriptor);
                }

                return this.buildFilter(item as FilterDescriptor);
            })
        };
    }

    protected buildFilter(filterDesc: FilterDescriptor) {
        if (!filterDesc.field && typeof filterDesc.field !== 'string') {
            return {};
        }

        const field = filterDesc.field as string;
        let value: any;

        switch (filterDesc.operator) {
            case 'eq':
                value = filterDesc.value;
                break;

            case 'neq':
                value = {
                    $ne: filterDesc.value
                };
                break;

            case 'isnull':
                value = null;
                break;

            case 'isnotnull':
                value = {
                    $ne: null
                };
                break;

            case 'lt':
            case 'lte':
            case 'gt':
            case 'gte':
                value = {
                    ['$' + filterDesc.operator]: filterDesc.value
                };
                break;

            case 'startswith':
                value = {
                    $regex: '^' + this.filterValueAsRegExp(filterDesc)
                };
                break;

            case 'endswith':
                value = {
                    $regex: '^.*' + this.filterValueAsRegExp(filterDesc) + '$'
                };
                break;

            case 'contains':
                value = {
                    $regex: '^.*' + this.filterValueAsRegExp(filterDesc) + '.*'
                };
                break;

            case 'doesnotcontain':
                value = {
                    $regex: '^((?!' + this.filterValueAsRegExp(filterDesc) + ').)*$'
                };
                break;

            case 'isempty':
                value = '';
                break;

            case 'isnotempty':
                value = {
                    $ne: ''
                };
                break;

            default:
                break;
        }

        return {
            [field]: value
        };
    }

    protected filterValueAsRegExp(filterDesc: FilterDescriptor): string {
        const value: string = (filterDesc.value || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

        if (filterDesc.ignoreCase) {
            return value
                .split('')
                .map(char => {
                    const upper = char.toUpperCase();
                    const lower = char.toLowerCase();
                    return upper !== lower ? `[${upper}${lower}]` : char;
                })
                .join('');
        }

        return value;
    }

    protected buildGroupInitial(groupDesc: GroupDescriptor): any {
        return groupDesc.aggregates.reduce((result: any, item) => {
            if (!result.agg[item.field]) {
                result.agg[item.field] = {};
            }

            switch (item.aggregate) {
                case AggregationType.count:
                case AggregationType.sum:
                    result.agg[item.field][item.aggregate] = 0;
                    break;

                case AggregationType.min:
                case AggregationType.max:
                    result.agg[item.field][item.aggregate] = null;
                    break;

                case AggregationType.average:
                    result.agg[item.field][item.aggregate] = { count: 0, sum: 0 };
                    break;

                default:
                    break;
            }

            return result;
        }, { agg: {} });
    }

    protected buildGroupReduce(groupDesc: GroupDescriptor): string {
        const funcBody = groupDesc.aggregates.map(item => {
            switch (item.aggregate) {
                case AggregationType.count:
                    return `out.agg['${item.field}'].count++;`;

                case AggregationType.sum:
                    return `out.agg['${item.field}'].sum += doc['${item.field}'];`;

                case AggregationType.min:
                    // tslint:disable-next-line:max-line-length
                    return `out.agg['${item.field}'].min = out.agg['${item.field}'].min === null ? doc['${item.field}'] : Math.min(out.agg['${item.field}'].min, doc['${item.field}']);`;

                case AggregationType.max:
                    // tslint:disable-next-line:max-line-length
                    return `out.agg['${item.field}'].max = out.agg['${item.field}'].max === null ? doc['${item.field}'] : Math.max(out.agg['${item.field}'].max, doc['${item.field}']);`;

                case AggregationType.average:
                    return `out.agg['${item.field}'].average.count++; out.agg['${item.field}'].average.sum += doc['${item.field}'];`;

                default:
                    break;
            }

            return '';
        }).join(' ');

        return `function(doc,out){ ${funcBody} return out; }`;
    }

    protected mapGroupResponse(groupDesc: GroupDescriptor, response: any[]): GroupResult[] {
        return (Array.isArray(response) && response || [response]).map(item => {
            const aggregates = Object.keys(item.agg).reduce((aggregateResult, key) => {
                const {average, ...rest } = item.agg[key];

                aggregateResult[key] = rest;

                if (average) {
                    aggregateResult[key].average = average.count > 0 ? average.sum / average.count : 0;
                }

                return aggregateResult;
            }, {});

            const result: GroupResult = {
                items: [],
                aggregates,
                field: groupDesc.field,
                value: item[groupDesc.field]
            };

            return result;
        });
    }
}
