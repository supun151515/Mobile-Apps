// -------------------------------------------------------------------------
// <Auto-generated file - do not modify!>
//
// This code was generated automatically by Kinvey Studio.
//
// Changes to this file may cause undesired behavior and will be lost
// the next time the code regenerates.
//
// Find more information on https://devcenter.kinvey.com/guides/studio-extension-points.
// -------------------------------------------------------------------------
import { Injector } from '@angular/core';
import { Observable, ConnectableObservable, BehaviorSubject, of } from 'rxjs';
import { first, publish, catchError, refCount } from 'rxjs/operators';

import { DataServiceConfig } from '@src/app/core/data/interfaces/data-service-config.interface';
import { PagingDataResult } from '@src/app/core/data/interfaces/paging-data-result.interface';
import { DataStateService, StateMap } from '@src/app/core/data//data-state.service';
import { AuthenticationService } from '@src/app/core/auth/authentication.service';
import { KinveyService } from '@src/app/core/data/kinvey.service';

export abstract class BaseDataService<T, TConfig extends DataServiceConfig, TState> {
    public readonly dataState: DataStateService<TState>;
    public readonly errors = new BehaviorSubject<Error>(null);
    public readonly isLoading = new BehaviorSubject<boolean>(false);

    public get dataChanges(): Observable<PagingDataResult<T> | T[] | T> {
        if (!this._dataChanges) {
            this._dataChanges = this.getDataChanges();
        }

        return this._dataChanges;
    }

    public get queryIdParam(): string {
        return `${this.config.modelTypeName}Id`;
    }

    protected kinveyService: KinveyService;
    protected authenticationService: AuthenticationService;

    private _dataChanges: Observable<PagingDataResult<T> | T[] | T>;

    constructor(protected injector: Injector, protected config: TConfig) {
        this.kinveyService = injector.get(KinveyService);
        this.authenticationService = injector.get(AuthenticationService);

        this.dataState = new DataStateService<TState>(this.combineStates);
    }

    public abstract refresh(): Promise<any>;

    protected abstract getDataChanges(): Observable<any>;
    protected abstract combineStates(stateMap: StateMap<TState>): TState;

    protected toPromise(action: () => void) {
        const connectableObservable = this.dataChanges.pipe(publish()) as ConnectableObservable<any>;
        connectableObservable.connect();
        action();

        return connectableObservable.pipe(refCount(), first()).toPromise();
    }

    protected handleError(error: Error) {
        if (!this.authenticationService.snapshot.isAuthenticated || this.authenticationService.isAuthError(error)) {
            this.authenticationService.authenticate();
            return;
        }

        this.isLoading.next(false);
        this.errors.next(error);
        console.error(error.stack || error.toString());
    }

    protected handleObservableError() {
        return catchError((error: Error) => {
            this.handleError(error);
            return of(null);
        });
    }

    protected handlePromiseError(error: Error) {
        this.handleError(error);
        throw error;
    }
}
