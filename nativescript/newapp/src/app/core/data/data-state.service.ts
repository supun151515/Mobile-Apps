// -------------------------------------------------------------------------
// <Auto-generated file - do not modify!>
//
// This code was generated automatically by Kinvey Studio.
//
// Changes to this file may cause undesired behavior and will be lost
// the next time the code regenerates.
//
// Find more information on https://devcenter.kinvey.com/guides/studio-extension-points.
// -------------------------------------------------------------------------
import { Observable, ReplaySubject, merge } from 'rxjs';
import { map, switchMap, filter, debounceTime, scan, shareReplay } from 'rxjs/operators';

export interface AggregationState {
    filter?: CompositeFilterDescriptor;
    group?: Array<GroupDescriptor>;
}

export interface EntityState {
    filter?: CompositeFilterDescriptor;
    id?: string;
}

export interface CollectionState {
    skip?: number;
    take?: number;
    sort?: Array<SortDescriptor>;
    filter?: CompositeFilterDescriptor;
    group?: Array<GroupDescriptor>;
    withinBox?: BoxLocationQuery;
}

export type DataState = CollectionState | EntityState | AggregationState;

export interface BoxLocationQuery {
    bottomLeftCoord: number[];
    upperRightCoord: number[];
}

export interface SortDescriptor {
    field: string;
    dir?: 'asc' | 'desc';
}

export interface FilterDescriptor {
    field?: string | Function;
    operator: string | Function;
    value?: any;
    ignoreCase?: boolean;
}

export interface CompositeFilterDescriptor {
    logic: 'or' | 'and';
    filters: Array<FilterDescriptor | CompositeFilterDescriptor>;
}

export const isCompositeFilterDescriptor = source => source.filters !== null && source.filters !== undefined;

export interface GroupDescriptor {
    field: string;
    dir?: 'asc' | 'desc';
    aggregates?: Array<AggregateDescriptor>;
}

export interface GroupResult {
    items: Object[];
    aggregates: AggregateResult;
    field: string;
    value: any;
}

export enum AggregationType {
    count = 'count',
    sum = 'sum',
    min = 'min',
    max = 'max',
    average = 'average'
}

export interface AggregateDescriptor {
    field: string;
    aggregate: 'count' | 'sum' | 'average' | 'min' | 'max';
}

export interface AggregateResult {
    [fieldName: string]: {
        count?: number;
        sum?: number;
        average?: number;
        min?: number;
        max?: number;
    };
}

export type StateReducer<TState> = (state: TState) => TState;
export type StateCombiner<TState> = (stateMap: StateMap<TState>) => TState;

export interface StateMap<TState> {
    [key: string]: TState;
}

interface StateItem<TState> {
    key: string;
    reducer: StateReducer<TState>;
}

export class DataStateService<TState extends CollectionState | EntityState> {
    public readonly changes: Observable<TState>;

    private keys = new Set<string>();
    private internalChanges = new ReplaySubject<StateReducer<TState>>(1);
    private changeSources = new ReplaySubject<Array<Observable<StateItem<TState>>>>(1);
    private stateReducers: Array<Observable<StateItem<TState>>> = [];

    constructor(protected combineStates: StateCombiner<TState>) {
        this.onChanges(this.internalChanges, 'internal');

        this.changes = this.changeSources.pipe(
            switchMap(items => merge(...items)),
            scan((oldStateMap, item) => {
                const newStateMap = { ...oldStateMap, [item.key]: item.reducer(oldStateMap[item.key]) };

                if (!newStateMap[item.key]) {
                    delete newStateMap[item.key];
                }

                return newStateMap;
            }, {} as StateMap<TState>),
            map(stateMap => this.combineStates(stateMap)),
            filter(state => !!state),
            shareReplay({
                bufferSize: 1,
                refCount: true
            })
        );
    }

    public update(reducer: StateReducer<TState>): void {
        this.internalChanges.next(reducer);
    }

    public onChanges(changeSource: Observable<StateReducer<TState>>, key = '') {
        key = this.setKey(key);

        this.stateReducers.push(changeSource.pipe(
            debounceTime(100),
            map(reducer => ({ key, reducer }))
        ));

        this.changeSources.next(this.stateReducers);

        return key;
    }

    private setKey(key: string): string {
        if (!key) {
            let index = 0;

            do {
                index++;
                key = `state-key-${index}`;
            } while (this.keys.has(key) && index < 1000);

            this.keys.add(key);
        }

        if (!this.keys.has(key)) {
            this.keys.add(key);
        }

        return key;
    }
}
