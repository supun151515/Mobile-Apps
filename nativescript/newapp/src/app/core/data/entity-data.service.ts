// -------------------------------------------------------------------------
// <Auto-generated file - do not modify!>
//
// This code was generated automatically by Kinvey Studio.
//
// Changes to this file may cause undesired behavior and will be lost
// the next time the code regenerates.
//
// Find more information on https://devcenter.kinvey.com/guides/studio-extension-points.
// -------------------------------------------------------------------------
import { Observable, Subject, merge } from 'rxjs';
import { flatMap, filter, last, map, tap, shareReplay, withLatestFrom } from 'rxjs/operators';

import { DataServiceConfig } from '@src/app/core/data/interfaces/data-service-config.interface';
import { combineFilters } from '@src/app/core/data/helpers/data-state-utils';
import { BaseDataService } from '@src/app/core/data/base-data.service';
import { StateMap, EntityState } from '@src/app/core/data/data-state.service';

export { EntityState };

export interface KinveyFileMetadata {
    _id?: string;
    filename?: string;
    mimeType?: string;
    public?: boolean;
    size?: number;
}

export class EntityDataService<T> extends BaseDataService<T, DataServiceConfig, EntityState> {
    public refresh(): Promise<any> {
        return this.toPromise(() => this.getDataReload().next());
    }

    public save(item: T) {
        return this.kinveyService.save(this.config, item)
            .then((newItem: any) => {
                this.getDataReload().next();

                // TODO: This would not work in offline mode
                this.dataState.update(state => {
                    if (!state) {
                        return;
                    }

                    if (state.filter) {
                        return state;
                    } else if (!state.id && newItem['_id']) {
                        state.id = newItem['_id'];
                        return state;
                    }
                });

                return newItem;
            })
            .catch(error => this.handlePromiseError(error));
    }

    public remove(item: T) {
        return this.kinveyService.remove(this.config, item)
            .then((result) => this.refresh().then(() => result))
            .catch(error => this.handlePromiseError(error));
    }

    public filesUpload(file: {}, metadata?: KinveyFileMetadata) {
        return this.kinveyService.filesUpload(this.config.requestOptions, file, metadata);
    }

    protected getDataChanges(): Observable<T> {
        const entityObservable = state => {
            let obs: Observable<T> = null;
            this.isLoading.next(true);

            if (state.id) {
                obs = this.kinveyService.findById(this.config, state.id).pipe(
                    this.handleObservableError(),
                    last(value => !!value),
                    map(item => this.mapData(item))
                );
            } else {
                obs = this.kinveyService.find(this.config, { filter: state.filter, take: 1 }).pipe(
                    this.handleObservableError(),
                    last(value => !!value),
                    map(item => item && item.length && this.mapData(item[0]))
                ) as Observable<T>;
            }

            return obs.pipe(
                tap(() => this.isLoading.next(false))
            );
        };

        return merge(
            this.getDataReload().pipe(
                withLatestFrom(this.dataState.changes),
                map(([_, state]) => state)
            ),
            this.dataState.changes
        ).pipe(
            filter(state => !!state.id || !!state.filter),
            flatMap(state => entityObservable(state)),
            shareReplay({
                bufferSize: 1,
                refCount: true
            })
        );
    }

    protected combineStates(stateMap: StateMap<EntityState>): EntityState {
        const combinedState = Object.values(stateMap).reduce((acc, state) => {
            if (!acc.id && state.hasOwnProperty('id')) {
                acc.id = state.id;
            }

            return acc;
        }, {});

        const stateFilter = combineFilters(Object.values(stateMap).filter(state => state.filter).map(state => state.filter));

        if (stateFilter) {
            combinedState.filter = stateFilter;
        }

        return combinedState;
    }

    protected getDataReload(): Subject<any> {
        return this.kinveyService.getDataReload(this.config.collection);
    }

    protected mapData(item: any): T {
        if (this.config.mapData) {
            return this.config.mapData(item);
        }

        return item;
    }
}
