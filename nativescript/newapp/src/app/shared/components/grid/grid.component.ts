// -------------------------------------------------------------------------
// <Auto-generated file - do not modify!>
//
// This code was generated automatically by Kinvey Studio.
//
// Changes to this file may cause undesired behavior and will be lost
// the next time the code regenerates.
//
// Find more information on https://devcenter.kinvey.com/guides/studio-extension-points.
// -------------------------------------------------------------------------
import { Component, ContentChild, Input, Output, EventEmitter, TemplateRef, AfterViewInit } from '@angular/core';
import { FormGroup } from '@angular/forms';

import { OperatorFunction } from 'rxjs';
import { map, switchMap } from 'rxjs/operators';

import { GridComponent, DataStateChangeEvent, SelectionEvent } from '@progress/kendo-angular-grid';
import { State } from '@progress/kendo-data-query';
import { DialogService, DialogRef, DialogAction } from '@progress/kendo-angular-dialog';

import { CollectionDataService } from '@src/app/core/data/collection-data.service';
import { FormGroupConfig, KsFormGroup, buildFormGroup } from '@src/app/core/helpers/form-utils';

const EDIT_MODE_READ_ONLY = 'ReadOnly';
const EDIT_MODE_INLINE = 'Inline';
const EDIT_MODE_POPUP = 'Popup';

export function selectedItemChange(getGrid: () => KsGridComponent): OperatorFunction<void, any> {
    return switchMap(() => getGrid().kendoGrid.selectionChange.pipe(
        map(event => event.selectedRows.length && event.selectedRows[0].dataItem)
    ));
}

@Component({
    selector: 'ks-grid',
    templateUrl: './grid.component.html',
})
export class KsGridComponent implements AfterViewInit {
    @ContentChild(GridComponent, { static: true }) public kendoGrid: GridComponent;

    @Input() public config: any;
    @Input() public formConfig: FormGroupConfig;
    @Input() public state: State = {};
    @Input() public dataService: CollectionDataService<any>;
    @Input() public errorTemplate: TemplateRef<any>;

    @Output() public add: EventEmitter<any> = new EventEmitter();
    @Output() public edit: EventEmitter<any> = new EventEmitter();
    @Output() public remove: EventEmitter<any> = new EventEmitter();
    @Output() public cellClick: EventEmitter<any> = new EventEmitter();
    @Output() public cellClose: EventEmitter<any> = new EventEmitter();

    public formGroup: KsFormGroup = new FormGroup({}) as KsFormGroup;
    public isNew: boolean;
    public popupActive = false;
    public selectedKeys: number[] = [];

    private editedRowIndex: number;
    private originalItem: any;

    constructor(public dialogService: DialogService) {}

    public ngAfterViewInit() {
        if (this.formConfig) {
            this.formGroup = buildFormGroup(this.formConfig);
        }
    }

    public selectionChange(e: SelectionEvent): void {
        this.originalItem = e.selectedRows.length ? e.selectedRows[0].dataItem : {};

        if (this.formConfig) {
            this.formGroup = buildFormGroup(this.formConfig);
            this.formGroup.patchValue(this.originalItem);
        }

        if (this.config.events && this.config.events.onRowSelect) {
            this.config.events.onRowSelect(e);
        }
    }

    public dataStateChange(gridState: DataStateChangeEvent): void {
        if (this.dataService) {
            this.dataService.dataState.update(() => gridState);
        }
    }

    public detailExpandHandler(e): void {
        if (this.config.events && this.config.events.onDetailExpand) {
            this.config.events.onDetailExpand(e);
        }
    }

    public detailCollapseHandler(e): void {
        if (this.config.events && this.config.events.onDetailCollapse) {
            this.config.events.onDetailCollapse(e);
        }
    }

    public addHandler(e) {
        const { sender } = e;
        this.originalItem = {};
        this.isNew = true;

        this.add.emit();

        if (this.config.events && this.config.events.onRowCreate) {
            this.config.events.onRowCreate(e);
        }

        this.formGroup = buildFormGroup(this.formConfig);
        this.formGroup.patchValue(this.dataService.createModel());

        switch (this.config.editing.mode) {
            case EDIT_MODE_INLINE:
                this.closeEditor(sender);
                sender.addRow(this.formGroup);
                break;

            case EDIT_MODE_POPUP:
                this.popupActive = true;
                break;

            default:
                break;
        }
    }

    public editHandler(e) {
        const { sender, rowIndex, dataItem } = e;
        this.originalItem = Object.assign({}, dataItem);
        this.isNew = false;

        this.edit.emit();

        if (this.config.events && this.config.events.onRowUpdate) {
            this.config.events.onRowUpdate(e);
        }

        this.formGroup = buildFormGroup(this.formConfig);
        this.formGroup.patchValue(dataItem);

        switch (this.config.editing.mode) {
            case EDIT_MODE_INLINE:
                this.closeEditor(sender);
                this.editedRowIndex = rowIndex;
                sender.editRow(rowIndex, this.formGroup);
                break;

            case EDIT_MODE_POPUP:
                this.popupActive = true;
                break;

            default:
                break;
        }
    }

    public cancelHandler({ sender, rowIndex }) {
        this.closeEditor(sender, rowIndex);
    }

    public saveHandler({ sender, rowIndex, formGroup = this.formGroup }) {
        if (!formGroup.valid) {
            Object.keys(formGroup.controls).forEach(key => {
                const control = formGroup.get(key);
                control.updateValueAndValidity({ onlySelf: true });
                control.markAsDirty();
            });

            return;
        }

        const rowItem = { ...this.originalItem, ...formGroup.value };
        switch (this.config.editing.mode) {
            case EDIT_MODE_INLINE:
                if (this.dataService) {
                    this.dataService.save(rowItem);
                }
                sender.closeRow(rowIndex);
                break;

            case EDIT_MODE_POPUP:
                if (this.dataService) {
                    this.dataService.save(rowItem);
                }
                this.popupActive = false;
                break;

            default:
                break;
        }

    }

    public removeHandler(e) {
        const { sender, dataItem } = e;
        if (this.config.events && this.config.events.onRowDelete) {
            this.config.events.onRowDelete(e);
        }

        if (this.config.confirmDelete) {
            const dialog = this.showDeleteConfirmation();

            dialog.result.subscribe((result: DialogAction) => {
                if (result.primary) {
                    this.removeAction(sender, dataItem);
                }
            });
        } else {
            this.removeAction(sender, dataItem);
        }
    }

    public showDeleteConfirmation(): DialogRef {
        return this.dialogService.open({
            title: 'Confirm delete',
            content: 'Are you sure you want to delete this record?',
            actions: [
                { text: 'No' },
                { text: 'Yes', primary: true }
            ],
            width: 450,
            height: 200,
            minWidth: 250
        });
    }

    protected removeAction(sender, dataItem) {
        this.remove.emit();
        if (this.dataService) {
            this.dataService.remove(dataItem);
        }
    }

    private closeEditor(grid, rowIndex = this.editedRowIndex) {
        switch (this.config.editing.mode) {
            case EDIT_MODE_INLINE:
                grid.closeRow(rowIndex);
                this.editedRowIndex = undefined;
                break;

            case EDIT_MODE_POPUP:
                this.popupActive = false;
                break;

            default:
                break;
        }
    }
}
