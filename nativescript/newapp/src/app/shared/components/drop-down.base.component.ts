// -------------------------------------------------------------------------
// <Auto-generated file - do not modify!>
//
// This code was generated automatically by Kinvey Studio.
//
// Changes to this file may cause undesired behavior and will be lost
// the next time the code regenerates.
//
// Find more information on https://devcenter.kinvey.com/guides/studio-extension-points.
// -------------------------------------------------------------------------
import { Input, Output, EventEmitter, OnInit } from '@angular/core';
import { FormGroup } from '@angular/forms';
import { Observable, ReplaySubject, merge } from 'rxjs';
import { map, tap, withLatestFrom, filter } from 'rxjs/operators';

import { KsInputBaseComponent } from '@src/app/shared/components/input.base.component';
import { DataStateService, CollectionState } from '@src/app/core/data/data-state.service';

export abstract class KsDropDownBaseComponent extends KsInputBaseComponent implements OnInit {
    @Input() public dataState: DataStateService<CollectionState>;

    @Input() public set data(value) {
        if (value) {
            if (Array.isArray(value)) {
                this.dataAsArray.next(value);
            } else if (Array.isArray(value.data)) {
                this.dataAsArray.next(value.data);
            }
        }
    }

    @Input() public loading: boolean;

    @Output() public filterChange: EventEmitter<string> = new EventEmitter();

    public dropDownData: Observable<Array<any>>;

    protected dataAsArray = new ReplaySubject<Array<any>>(1);
    protected preventPopupOpen = true;

    public ngOnInit() {
        this.dropDownData = this.getData();
    }

    public changeHandler(event: any): void {
        const value = event && event.srcElement && event.srcElement.value;
        super.updateValue(value || '');
    }

    public openHandler(event: any) {
        if (this.config.filterable && !this.config.clientFiltering) {
            event.preventDefault();
            this.preventPopupOpen = false;
        }
    }

    public filterHandler(filterValue: string): void {
        this.filterChange.emit(filterValue);
    }

    protected abstract getFilterFieldName(): string;
    protected abstract getChildFilterChange(): EventEmitter<string>;
    protected abstract openPopup(): void;

    protected getData(): Observable<any> {
        const dataChanges = this.dataAsArray.pipe(
            tap(() => {
                if (!this.preventPopupOpen) {
                    this.openPopup();
                }
            })
        );

        if (this.config.filterable && this.config.clientFiltering) {
            const filterChange = this.getChildFilterChange().pipe(
                withLatestFrom(dataChanges),
                map(([filterValue, data]) => data.filter(item => this.filterItem(item, filterValue)))
            );

            return merge(dataChanges, filterChange);
        }

        if (this.config.filterable && !this.config.clientFiltering) {
            this.dataState.onChanges(this.getChildFilterChange().pipe(
                filter(filterValue => !!filterValue),
                map(filterValue => () => this.getFilter(filterValue))
            ));
        }

        return dataChanges;
    }

    protected filterItem(item: any, filterValue: string): boolean {
        if (!filterValue) {
            return true;
        }

        const filterFieldName = this.getFilterFieldName();
        const itemText = ((filterFieldName ? item[filterFieldName] : item) || '').toLowerCase();
        const filterText = filterValue.toLowerCase();

        switch (this.config.filter) {
            case 'StartsWith':
                return itemText.indexOf(filterText) === 0;
            case 'EndsWith':
                return itemText.indexOf(filterText, itemText.length - filterText.length) !== -1;
            case 'Contains':
                return itemText.indexOf(filterText) !== -1;
            default:
                return true;
        }
    }

    protected getFilter(filterValue: string): CollectionState {
        return {
            filter: {
                logic: 'or',
                filters: [
                    {
                        field: this.getFilterFieldName(),
                        operator: this.config.filter.toLowerCase(),
                        value: filterValue,
                        ignoreCase: true
                    }
                ]
            }
        };
    }
}
