// -------------------------------------------------------------------------
// <Auto-generated file - do not modify!>
//
// This code was generated automatically by Kinvey Studio.
//
// Changes to this file may cause undesired behavior and will be lost
// the next time the code regenerates.
//
// Find more information on https://devcenter.kinvey.com/guides/studio-extension-points.
// -------------------------------------------------------------------------
import { Component, Input, Output, EventEmitter, TemplateRef, ChangeDetectorRef } from '@angular/core';
import { AbstractControl, FormControl, FormGroup, FormArray } from '@angular/forms';

import { Observable, ReplaySubject } from 'rxjs';

import { NotificationService } from '@src/app/core/notification/notification.service';
import { Notification } from '@src/app/core/notification/notification';
import { AsyncEvent, asyncEmit } from '@src/app/core/helpers/async-event';
import { KsFormGroup, FormGroupConfig, FormItemConfig } from '@src/app/core/helpers/form-utils';

@Component({
    selector: 'ks-form',
    templateUrl: './form.component.html',
})
export class KsFormComponent {
    @Input() public formGroup: KsFormGroup;
    @Input() public errorTemplate: TemplateRef<any>;

    @Input() set data(value: any) {
        this.updateFormGroupValue(value);
    }

    @Output() public formSubmit = new EventEmitter<AsyncEvent>();

    public asyncInputs: Promise<void>[] = [];
    public originalItem = {};
    public isLoading = false;
    public readonly formSubmits: Observable<any>;

    protected submitEvents = new ReplaySubject(1);

    constructor(protected cdr: ChangeDetectorRef, protected notificationService: NotificationService) {
        this.formSubmits = this.submitEvents.asObservable();
    }

    public get isValid() {
        return this.formGroup.valid;
    }

    public submit(): Promise<any> {
        this.isLoading = true;
        this.cdr.detectChanges();

        return Promise.all(this.asyncInputs)
            .then(() => {
                this.submitEvents.next();

                return !this.isValid || asyncEmit(this.formSubmit, {
                    item: { ...this.originalItem, ...this.formGroup.getRawValue() }
                });
            })
            .then(() => {
                this.isLoading = false;
                this.cdr.detectChanges();
            })
            .catch(err => {
                this.notificationService.notify(new Notification(err && err.message || 'An error has occurred.', 'error'));
            });
    }

    public reset() {
        this.formGroup.reset(this.originalItem);
    }

    public onRegisterAsyncInput(asyncInput: Promise<void>) {
        this.asyncInputs.push(asyncInput);
    }

    protected updateFormGroupValue(value: any): void {
        if (!value) {
            return;
        }

        this.originalItem = value;
        this.initFormArrays(this.formGroup, this.formGroup.config, value);
        this.formGroup.patchValue(value);
    }

    protected initFormArrays(formGroup: FormGroup, formConfig: FormGroupConfig, value: any): void {
        if (!value) {
            return;
        }

        Object.keys(formConfig.controls).forEach(key => {
            const control = formConfig.controls[key];

            if (control.type === 'group') {
                this.initFormArrays(formGroup.get(key) as FormGroup, control, value[key]);
            } else if (control.type === 'array' && Array.isArray(value[key])) {
                this.createFormArrayControls(formGroup.get(key) as FormArray, control.control, value[key]);
            }
        });
    }

    protected createFormArrayControls(formArray: FormArray, arrayControlConfig: FormItemConfig, value: Array<any>): void {
        formArray.clear();
        const valueLength = value.length;

        for (let i = 0; i < valueLength; i++) {
            formArray.push(this.createControl(arrayControlConfig, value[i]));
        }
    }

    protected createControl(config: FormItemConfig, value: any): AbstractControl {
        switch (config.type) {
            case 'control':
                return new FormControl(config.initial, config.options);

            case 'group':
                const controls = {};

                Object.keys(config.controls).forEach(key => {
                    controls[key] = this.createControl(config.controls[key], value[key]);
                });

                return new FormGroup(controls, config.options);

            case 'array':
                const formArray = new FormArray([]);
                this.createFormArrayControls(formArray, config.control, value);
                return formArray;

            default:
                break;
        }
    }
}
