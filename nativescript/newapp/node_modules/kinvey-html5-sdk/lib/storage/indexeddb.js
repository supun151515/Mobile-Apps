Object.defineProperty(exports, "__esModule", { value: true });
var DB_CACHE = {};
var IndexedDBTransactionMode = {
    readWrite: 'readwrite',
    readOnly: 'readonly',
};
var IndexedDB = /** @class */ (function () {
    function IndexedDB(dbName) {
        this.dbName = dbName;
        this.db = DB_CACHE[this.dbName];
        this.inTransaction = false;
        this.queue = [];
    }
    Object.defineProperty(IndexedDB.prototype, "db", {
        get: function () {
            return this._db;
        },
        set: function (db) {
            if (db) {
                this._db = db;
                DB_CACHE[this.dbName] = db;
            }
            else {
                this._db = null;
                delete DB_CACHE[this.dbName];
            }
        },
        enumerable: true,
        configurable: true
    });
    IndexedDB.prototype.hasObjectStore = function (objectStoreName) {
        if (this.db && this.db.objectStoreName) {
            return typeof this.db.objectStoreNames.contains === 'function'
                ? this.db.objectStoreNames.contains(objectStoreName)
                : this.db.objectStoreNames.indexOf(objectStoreName) !== -1;
        }
        return false;
    };
    IndexedDB.prototype.openTransaction = function (objectStoreName, mode) {
        if (mode === void 0) { mode = IndexedDBTransactionMode.readOnly; }
        var txn = this.db.transaction(objectStoreName, mode);
        if (!txn) {
            throw new Error("Unable to open a transaction for " + objectStoreName + " collection on the " + this.dbName + " IndexedDB database.");
        }
        return txn;
    };
    IndexedDB.prototype.openDB = function () {
        var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;
        if (this.db) {
            var version = this.db.version + 1;
            this.close();
            return indexedDB.open(this.dbName, version);
        }
        return indexedDB.open(this.dbName);
    };
    IndexedDB.prototype.open = function (objectStoreName, write, success, error, force) {
        var _this = this;
        if (write === void 0) { write = false; }
        if (force === void 0) { force = false; }
        try {
            if (this.db) {
                if (this.db.objectStoreNames.contains(objectStoreName)) {
                    var mode = write ? IndexedDBTransactionMode.readWrite : IndexedDBTransactionMode.readOnly;
                    return success(this.openTransaction(objectStoreName, mode));
                }
                else if (!write) {
                    throw new Error("The " + objectStoreName + " collection was not found on the " + this.dbName + " IndexedDB database.");
                }
            }
            if (!force && this.inTransaction) {
                return this.queue.push(function () { return _this.open(objectStoreName, write, success, error); });
            }
            this.inTransaction = true;
            var request = this.openDB();
            // If the database is opened with an higher version than its current, the
            // `upgradeneeded` event is fired. Save the handle to the database, and
            // create the collection.
            request.onupgradeneeded = function (e) {
                _this.db = e.target.result;
                if (write && !_this.db.objectStoreNames.contains(objectStoreName)) {
                    _this.db.createObjectStore(objectStoreName, { keyPath: '_id' });
                }
            };
            // The `success` event is fired after `upgradeneeded` terminates.
            // Save the handle to the database.
            request.onsuccess = function (e) {
                _this.db = e.target.result;
                // If a second instance of the same IndexedDB database performs an
                // upgrade operation, the `versionchange` event is fired. Then, close the
                // database to allow the external upgrade to proceed.
                _this.db.onversionchange = function () { return _this.close(); };
                // Try to obtain the collection handle by recursing. Append the handlers
                // to empty the queue upon success and failure. Set the `force` flag so
                // all but the current transaction remain queued.
                var wrap = function (done) {
                    var callbackFn = function (arg) {
                        done(arg);
                        // Switch flag
                        _this.inTransaction = false;
                        // The database handle has been established, we can now safely empty
                        // the queue. The queue must be emptied before invoking the concurrent
                        // operations to avoid infinite recursion.
                        if (_this.queue.length > 0) {
                            var pending = _this.queue;
                            _this.queue = [];
                            pending.forEach(function (fn) {
                                fn.call(_this);
                            });
                        }
                    };
                    return callbackFn;
                };
                return _this.open(objectStoreName, write, wrap(success), wrap(error), true);
            };
            // The `blocked` event is not handled. In case such an event occurs, it
            // will resolve itself since the `versionchange` event handler will close
            // the conflicting database and enable the `blocked` event to continue.
            request.onblocked = function () { };
            // Handle errors
            request.onerror = function (e) {
                error(new Error("Unable to open the " + _this.dbName + " IndexedDB database. " + e.target.error.message + "."));
            };
        }
        catch (e) {
            error(e);
        }
        return null;
    };
    IndexedDB.prototype.close = function () {
        if (this.db) {
            this.db.close();
            this.db = null;
        }
    };
    return IndexedDB;
}());
function find(dbName, objectStoreName) {
    var db = new IndexedDB(dbName);
    return new Promise(function (resolve, reject) {
        db.open(objectStoreName, false, function (txn) {
            var store = txn.objectStore(objectStoreName);
            var request = store.openCursor();
            var docs = [];
            request.onsuccess = function (e) {
                var cursor = e.target.result;
                if (cursor) {
                    docs.push(cursor.value);
                    return cursor.continue();
                }
                return resolve(docs);
            };
            request.onerror = function (e) {
                reject(e.target.error);
            };
        }, function (error) {
            if (error.message.indexOf('not found') !== -1) {
                resolve([]);
            }
            else {
                reject(error);
            }
        });
    });
}
exports.find = find;
function count(dbName, objectStoreName) {
    var db = new IndexedDB(dbName);
    return new Promise(function (resolve, reject) {
        db.open(objectStoreName, false, function (txn) {
            var store = txn.objectStore(objectStoreName);
            var request = store.count();
            request.onsuccess = function () { return resolve(request.result); };
            request.onerror = function (e) { return reject(e.target.error); };
        }, function (error) {
            if (error.message.indexOf('not found') !== -1) {
                resolve(0);
            }
            else {
                reject(error);
            }
        });
    });
}
exports.count = count;
function findById(dbName, objectStoreName, id) {
    var db = new IndexedDB(dbName);
    return new Promise(function (resolve, reject) {
        db.open(objectStoreName, false, function (txn) {
            var store = txn.objectStore(objectStoreName);
            var request = store.get(id);
            request.onsuccess = function (e) {
                resolve(e.target.result);
            };
            request.onerror = function (e) {
                reject(e.target.error);
            };
        }, reject);
    });
}
exports.findById = findById;
function save(dbName, objectStoreName, docs) {
    if (docs === void 0) { docs = []; }
    var db = new IndexedDB(dbName);
    return new Promise(function (resolve, reject) {
        db.open(objectStoreName, true, function (txn) {
            var store = txn.objectStore(objectStoreName);
            var docsToSave = docs;
            if (!Array.isArray(docs)) {
                docsToSave = [docs];
            }
            docsToSave.forEach(function (doc) {
                store.put(doc);
            });
            txn.oncomplete = function () {
                resolve(docs);
            };
            txn.onerror = function (e) {
                reject(new Error("An error occurred while saving the entities to the " + objectStoreName + " collection on the " + dbName + " IndexedDB database. " + e.target.error.message + "."));
            };
        }, reject);
    });
}
exports.save = save;
function removeById(dbName, objectStoreName, id) {
    var db = new IndexedDB(dbName);
    return new Promise(function (resolve, reject) {
        db.open(objectStoreName, true, function (txn) {
            var store = txn.objectStore(objectStoreName);
            var request = store.get(id);
            store.delete(id);
            txn.oncomplete = function () {
                var doc = request.result;
                if (doc) {
                    resolve(1);
                }
                else {
                    reject(new Error("An entity with _id = " + id + " was not found in the " + objectStoreName + " collection on the " + dbName + " database."));
                }
            };
            txn.onerror = function () {
                reject(new Error("An entity with _id = " + id + " was not found in the " + objectStoreName + " collection on the " + dbName + " database."));
            };
        }, reject);
    });
}
exports.removeById = removeById;
function clear(dbName, objectStoreName) {
    var db = new IndexedDB(dbName);
    return new Promise(function (resolve, reject) {
        db.open(objectStoreName, true, function (txn) {
            var objectStore = txn.objectStore(objectStoreName);
            objectStore.clear();
            txn.oncomplete = function () { return resolve(true); };
            txn.onerror = function (err) { return reject(err); };
        }, reject);
    });
}
exports.clear = clear;
function clearDatabase(dbName) {
    return new Promise(function (resolve, reject) {
        var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;
        var request = indexedDB.deleteDatabase(dbName);
        request.onsuccess = function () {
            delete DB_CACHE[dbName];
            resolve(true);
        };
        request.onerror = function (e) {
            reject(new Error("An error occurred while clearing the " + dbName + " IndexedDB database. " + e.target.error.message + "."));
        };
        request.onblocked = function () {
            reject(new Error("The " + dbName + " IndexedDB database could not be cleared due to the operation being blocked."));
        };
    });
}
exports.clearDatabase = clearDatabase;
//# sourceMappingURL=indexeddb.js.map